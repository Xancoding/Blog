---
title: "操作系统" # 标题
date: 2022-11-15T12:04:42+08:00 # 创建时间
author: ["Xan"] # 作者
tags: # 标签
- Tech
- 计算机基础
- 操作系统
keywords: # 关键词
- Tech
- 计算机基础
- 操作系统
description: "" # 描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true # 是否展示评论
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true # 顶部显示当前路径
cover:
    image: "" #图片路径 例：posts/tech/123/picture.png
    caption: "" # 图片底部描述
    alt: ""
    relative: false
---

# 记录型信号量
```cpp
S：信号量的值。当其值大于 0 时，表示可供使用的资源数；当其值小于 0 时，其绝对值表示等待使用该资源的进程数

/* P 操作的定义 */
P(S)
{
	S.value--;
	if (S.value < 0) 
	{
		// 将该进程加到 S.list 队列
		block();
	}
}

/* V 操作的定义 */
V(S)
{
	S.value++;
	if (S.value <= 0)
	{
		// 从 S.list 队列中将 Q 移走
		wakeup(Q);
	}
}
```
## 互斥
# 进程同步问题
## 生产者--消费者
假设有一个缓冲区，生产者往其中生产数据，消费者从其中取出数据。生产者和消费者各有若干个，它们之间需要通过缓冲区进行数据交换。

1.  初始化信号量：

-   empty：计数信号量，初始值为N，表示缓冲区空闲的数量。
-   full：计数信号量，初始值为0，表示缓冲区中已经存放的数据量。
-   mutex：互斥信号量，初始值为1，用于保护缓冲区的互斥访问。

2.  生产者过程：
```scss
while (true) {
    produce(item);  // 生产数据
    P(empty);  // 等待空闲缓冲区
    P(mutex);  // 占用缓冲区
    put(item);  // 将数据放入缓冲区
    V(mutex);  // 释放缓冲区
    V(full);  // 增加缓冲区已有数据的数量
}

```

3.  消费者过程：
```scss
while (true) {
    P(full);  // 等待有数据的缓冲区
    P(mutex);  // 占用缓冲区
    item = get();  // 从缓冲区取出数据
    V(mutex);  // 释放缓冲区
    V(empty);  // 增加空闲缓冲区的数量
    consume(item);  // 消费数据
}

```

在这个过程中，P操作表示进程占用一个信号量资源，V操作表示进程释放一个信号量资源。对于互斥信号量mutex，每次只有一个进程可以占用资源，以保证缓冲区的互斥访问。对于计数信号量empty和full，它们都是等待队列，生产者和消费者通过占用和释放信号量来加入和离开等待队列。
## 理发师问题
### 问题描述

一个理发店有一个理发师和若干个顾客。理发师可以理发，顾客可以等待理发或者离开。当顾客进入理发店时，如果理发师忙，顾客就等待。如果理发师闲着，顾客就可以马上得到理发。理发师理完一位顾客的头发后，会从等待区中选择一个顾客进行服务。

问题的关键在于如何使理发师和顾客之间进行合理的协作，避免死锁和饥饿的问题。

### 解决办法

经典的解决方法是使用信号量机制实现同步。定义以下信号量：

- customers：计数信号量，初始值为0，表示等待理发的顾客数量。 
- barber：互斥信号量，初始值为1，用于控制理发师的访问。 
- mutex：互斥信号量，初始值为1，用于保护customers计数信号量的互斥访问。

理发师过程： 
```scss
while (true) {
    P(customers);  // 等待有顾客到来
    P(mutex);  // 占用顾客数量计数信号量
    customer = dequeue();  // 从顾客队列中取出一个顾客
    V(mutex);  // 释放顾客数量计数信号量
    cut_hair(customer);  // 为顾客理发
    V(barber);  // 理发
```
顾客过程： 
```scss
while (true) {
    P(mutex);  // 占用顾客数量计数信号量
    if (customers < chairs) {  // 如果有空椅子
        enqueue(customer);  // 排队等待理发
        V(customers);  // 增加等待的顾客数量
        V(mutex);  // 释放顾客数量计数信号量
        P(barber);  // 等待理发师空闲
        get_haircut(customer);  // 接受理发师的服务
    } else {  // 如果没有空椅子，离开
        V(mutex);  // 释放顾客数量计数信号量
        leave(customer);  // 离开理发店
    }
}

```

在这个过程中，P操作表示进程占用一个信号量资源，V操作表示进程释放一个信号量资源。对于互斥信号量barber和mutex，每次只有一个进程可以占用资源，以保证对理发师和顾客队列的互斥访问。对于计数信号量customers，它是一个等待队列，顾客通过占用和释放信号量来加入和离开等待队列，而理发师则通过占用和释放信号量来控制顾客的理发顺序。
## 读者--写者问题
### 问题描述
-   多个读者和写者共享一个资源，读者可以同时读取该资源，但写者进行写操作时需要独占该资源；
-   写者优先级高于读者，即当有写者等待时，不允许新的读者访问资源，直到所有写者完成写操作；
-   读写操作的互斥性，即在同一时刻只允许一个读写操作进行。
### 解决办法
- wmutex：计数信号量，初始值为1，用于保护写操作的互斥访问。 
- rmutex：计数信号量，初始值为1，用于互斥访问 readcount。
- readcount：整型变量，初始值为0，表示读者计数器

写者：
```scss
while (true) {
    P(wmutex);        // 请求写访问权
    write_data();    // 写操作
    V(wmutex);        // 释放写访问权
}
```

读者：
```scss
while (true) {

  P(rmutex); // 保证对计数器的互斥访问
  readcount++; // 有一个读者进入临界区
  if (readcount == 1) { // 如果是第一个读者
    P(wmutex); // 请求写访问权，禁止写者同时写入
  }
  V(rmutex); // 释放对计数器的访问
  
  read_data(); // 读操作

  P(rmutex); // 保证对计数器的互斥访问
  readcount--; // 有一个读者离开临界区
  if (readers == 0) { // 如果是最后一个读者
    V(wmutex); // 释放写访问权
  }
  V(rmutex); // 释放对计数器的访问
}
```

## 哲学家就餐问题
### 问题描述
在一个圆形餐桌上坐着N个哲学家，每个哲学家面前有一盘食物和一只叉子。这些哲学家只有在同时拿到自己面前的两个叉子时才能进食。每个哲学家都有两个邻居，因此有N个叉子。

问题的关键在于如何使哲学家能够避免死锁和饥饿地进食。
### 解决办法
解决哲学家就餐问题的一种常见方法是使用资源分级和时间限制。以下是一种解决方案：

1.  给每个叉子都分配一个编号，从1到N。
2.  哲学家只有在同时拿到两个编号为i和(i+1)%N的叉子时才能吃饭。
3.  为了避免死锁，可以采用两种方法之一：
    -   方法一：将一个叉子的拿取和放下操作定义为原子性操作，采用信号量来实现同步。每个哲学家需要先尝试获取自己左右两个叉子的信号量，只有在同时获取到两个信号量时才能进食。在哲学家用完餐具后，释放这两个信号量，让其他哲学家能够使用这些餐具。
    -   方法二：引入一个“服务员”线程，服务员维护一个计数器，记录当前使用餐具的数量。当哲学家需要进餐时，需要向服务员发出请求。服务员检查当前使用餐具的数量是否已经达到了N-1，如果是，则等待一段时间再重新检查，直到有餐具被释放出来。如果不是，则服务员将餐具分配给该哲学家。哲学家用完餐具后，将餐具归还给服务员。

需要注意的是，无论是哪种方法，都需要遵循以下两个原则：

-   要确保每个哲学家都能获得进餐的机会，避免饥饿。
-   要确保所有哲学家都能进餐，而不会导致死锁。
## 图书馆阅览室问题
### 问题描述
假定阅览室最多可同时容纳 100 个人阅读，读者进入时，必须在阅览室门口的一个登记表上登记，内容包括姓名、座号等，离开时要撤掉登记内容。用P、V操作描述读者进程的同步算法。
### 解决办法
- count：整型变量，初始值为100，用于记录阅览室的空闲座位数
- mutex：计数信号量，初始值为1，用于互斥访问登记表
```scss
Enter：进入进程
while (true) {
	P(mutex);
	if(count > 0) {
		count--;  
		登记登记表
	} 
	V(mutex);
}

Leave：离开进程
while(true) {
	P(mutex);
	count++;
	撤销登记表
	V(mutex);
}
```
# 推荐阅读
-  [NJU操作系统](https://www.bilibili.com/video/BV1Cm4y1d7Ur/?spm_id_from=333.788)
	-  [操作系统：设计与实现 (2022 春季学期)](http://jyywiki.cn/OS/2022/)
- [【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统](https://www.bilibili.com/video/BV1iW411d7hd?p=1&vd_source=ae16ff6478eb15c1b87880540263910b)
***
- [《操作系统导论》](https://book.douban.com/subject/33463930/)
- [《现代操作系统》（原书第4版）](https://book.douban.com/subject/27096665/)
- [《操作系统:精髓与设计原理》](https://book.douban.com/subject/5064311/)
- **[《深入理解计算机系统（原书第3版）》CSAPP](https://book.douban.com/subject/26912767/)**
	- **计算机组成 + 操作系统 + 汇编 + C语言 + Linux系统编程**
{{< douban src="https://book.douban.com/subject/33463930/" >}}
{{< douban src="https://book.douban.com/subject/27096665/" >}}
{{< douban src="https://book.douban.com/subject/5064311/" >}}
{{< douban src="https://book.douban.com/subject/26912767/" >}}
