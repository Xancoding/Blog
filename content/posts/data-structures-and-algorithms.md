---
title: "数据结构与算法" # 标题
date: 2022-10-18T17:16:53+08:00 # 创建时间
author: ["Xan"] # 作者
tags: # 标签
- Tech
- 计算机基础
- 数据结构与算法
keywords: # 关键词
- Tech
- 计算机基础
- 数据结构与算法
description: "" # 描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true # 是否展示评论
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true # 顶部显示当前路径
cover:
    image: "" #图片路径 例：posts/tech/123/picture.png
    caption: "" # 图片底部描述
    alt: ""
    relative: false
---

# 分治法
分治法的关键步骤包括：
1. 分成子问题
2. 递归处理子问题
3. 子问题合并

分治法是一种求解问题的策略，而递归是一种实现求解算法的技术

改进分治算法的途径有 **减少子问题个数** 和 **增加预处理**。

在分治法处理中，实践证明，采用 **平衡子问题** 思想划分子问题总是有较好的结果。

在大整数乘法和矩阵乘中，可以采取降低  **乘法** 的运算次数来降低时间复杂度

分治法的设计思想是将一个难以直接解决的大问题分割成规模较小的子问题，分别解决子问题，最后将子问题的解组合起来形成原问题的解。这要求原问题和子问题 **问题规模不同，问题性质相同**
# 动态规划
虽然动态规划算法通常用于解决具有**重叠子问题**的问题，但是这并不是动态规划的必要条件。

动态规划算法的两个基本要素是 **无后效性** 性质和 **最优子结构** 性质 。

问题的 **子问题重叠** 是该问题可用动态规划算法或贪心算法求解的关键特征。

备忘录/填表方法是 **动态规划法** 算法的变形

动态规划算法基本要素的是 **子问题重叠**

动态规划算法的关键步骤包括：
1. 确定状态和状态转移方程
2. 确定初始状态和边界条件
3. 确定子问题求解顺序

**有重叠子问题并不是动态规划的必要条件**：
这是正确的。动态规划算法的核心思想是将一个大问题分解成许多小问题，并使用这些小问题的解来构建大问题的解。通常情况下，这些小问题是相互独立的，但是如果它们之间存在重叠，也就是说它们具有相同的子问题，那么动态规划算法可以利用这些重叠来避免重复计算，从而提高效率。  
然而，并不是所有的动态规划问题都具有重叠子问题。例如，有些动态规划问题只是简单地将一个问题分解成许多相互独立的子问题，而不是使用重叠子问题来避免重复计算。  
因此，具有重叠子问题并不是动态规划算法的必要条件，但是如果存在重叠子问题，动态规划算法可以更加高效地解决问题。  

**动态规划算法设计中标记函数不是必须的**
标记函数是指在动态规划算法中使用的一种技巧，用于记录某些子问题是否已经被求解过。当一个子问题被解决后，标记函数可以将其标记为已解决，从而在后续的计算中避免重复计算。标记函数通常用一个数组或哈希表来实现。  
尽管标记函数在许多动态规划问题中都非常有用，但并不是所有的动态规划问题都需要使用标记函数。实际上，有些动态规划问题的状态转移方程不需要考虑子问题是否已经被求解过，因为它们的状态转移方程本身已经保证了没有重复计算的问题。  
因此，动态规划算法设计中是否需要包含标记函数，取决于具体的问题和算法设计。在一些情况下，标记函数可以提高算法的效率，但在另一些情况下，它们可能不是必需的。

**状态转移方程和标记函数是两个不同的概念，在动态规划算法中起着不同的作用。**
状态转移方程是描述问题中子问题之间的转移关系，通常用来计算当前子问题的最优解。在动态规划算法中，我们将原问题分解成若干个子问题，并使用状态转移方程计算子问题的最优解，从而逐步构建出原问题的最优解。  
标记函数则是用来标记子问题的解是否已经被计算过。在动态规划算法中，由于子问题之间存在重叠，可能会重复计算同一个子问题的解，导致算法效率下降。标记函数可以用来避免这种情况的发生，当一个子问题的解已经被计算过后，我们可以将其标记为已计算，避免重复计算。  
在某些情况下，状态转移方程和标记函数可能是紧密相关的，例如在使用记忆化搜索优化动态规划算法时，我们通常会将已计算的子问题的解保存在一个表格中，作为标记函数来使用。但在其他情况下，状态转移方程和标记函数可能是相对独立的，可以根据具体问题和算法设计来灵活选择是否使用标记函数。
# 贪心法
**n皇后问题** 不能使用贪心法解决

贪心算法的基本要素的是 **定义最优解**
# 回溯法
请画出用回溯法解n=3的0-1背包问题的解空间树和当三个物品的重量为{16, 15, 15}，价值为{45, 25, 25}，背包容量为30时搜索空间树
![回溯法.jpg](https://bu.dusays.com/2023/05/12/645e4ab203f4e.jpg)
回溯法有“通用解题法”之称，它可以系统地搜索一个问题的所有解或任意解

回溯法是一种既带系统性又带有跳跃性的搜索算法

回溯算法在生成解空间的任一结点时，先判断该结点是否可能包含问题的解，如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向祖先结点回溯

回溯法的解空间树有 **子集树**、**排列树**、**n 叉树**

回溯法是一种 **带剪枝** 的穷举法，它采用了 **深度优先** 搜索方式，求得问题的 **最优解** 或所有解

回溯法中用到的两种约束条件是 **目标函数和约束函数** 两种

回溯法的效率不依赖于 **确定解空间的时间**

**剪枝函数** 函数是回溯法中为避免无效搜索采取的策略
# 分支限界法 
限重 15
![image.png](https://bu.dusays.com/2023/05/19/646784c7b5b5f.png)
![分支限界法.jpg](https://bu.dusays.com/2023/05/12/645e4abaac35f.jpg)
优先队列式分枝限界法选取扩展结点的原则是 **结点的优先级**

采用最大效益优先搜索方式的算法是 **分支限界法**

分支限界法求解0/1背包问题时，活结点表的组织形式是 **大根堆**

常见的两种分支限界法为 **队列式（FIFO）分支限界法与优先队列式分支限界法**

分支限界法在问题的解空间树中，按 **广度优先** 策略，从根结点出发搜索解空间树
# 递推式的计算
## 主定理
假设 $T(n)$ 是一个递归算法的时间复杂度，其中 $n$ 是输入规模。假设算法分解问题时，将其划分为 $a$ 个子问题，每个子问题的规模为原问题的 $1/b$，且每个子问题的解需要 $f(n)$ 的时间。即：
$$T(n) = aT(n/b) + f(n)$$

假设分解问题和合并子问题的过程需要常数时间 $d$，那么主定理的公式如下：
### 易记（不严谨）
1.  如果 $f(n) < O(n^{\log_b(a)})$，那么 $T(n) = \Theta(n^{\log_b(a)})$
    
2.  如果 $f(n) = \Theta(n^{\log_b(a)})$，那么 $T(n) = \Theta(n^{\log_b(a)} \log n)$
    
3.  如果 $f(n) > \Omega(n^{\log_b(a)})$，那么 $T(n) = \Theta(f(n))$。
    

这里的比较指的是数量级的大小
### 严谨
1.  如果 $f(n) = O(n^{\log_b(a - \epsilon)})$，那么 $T(n) = \Theta(n^{\log_b(a)})$
    
2.  如果 $f(n) = \Theta(n^{\log_b(a)})$，那么 $T(n) = \Theta(n^{\log_b(a)} \log n)$
    
3.  如果 $f(n) = \Omega(n^{\log_b(a + \epsilon)})$，且对于某个常数 $c < 1$ 和所有足够大的 $n$ 都有 $af(n/b) \le cf(n)$，那么 $T(n) = \Theta(f(n))$。
    

其中 $\epsilon > 0$ 是任意小的正数。这里的 $O$、$\Theta$ 和 $\Omega$ 表示渐进符号。

### 主定理没有覆盖所有情况
如果情况一和三的渐进小于或大于不是多项式意义上的，而是logn之类的，就不能应用主定理。
![image.png](https://bu.dusays.com/2023/05/22/646b5aefbc0f8.png)
![image.png](https://bu.dusays.com/2023/05/22/646b67a54f600.png)


# P & NP & NPC & NP-Hard 
NP问题是指可以在多项式的时间里验证一个解的问题

若一个问题可以找到一个能在多项式的时间里解决它的算法，该问题就属于P问题

NPC问题指的是NP问题中最难的问题之一，同时也是NP问题中的一个子集，因此只要能将所有的NP问题约化为它，它就是NP问题。

所有的P类问题都是NP问题的子集。
  
P:  能在多项式时间内解决的问题

NP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但 能在多项式时间验证的问题

NPC: NP完全问题， 所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题 ，即解决了此NPC问题，所有NP问题也都得到解决。

NP hard:NP难问题， 所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)。


![cc8d355f43502c3dc2d4fa54c9fd2b5.png](https://bu.dusays.com/2023/05/22/646b67bd57092.png)

# 其他知识点
描述算法时间增长率上限用 **O** 符号，增长率下限用 **Ω** 符号表示。

图灵机模型的基本结构包括 纸带,**读写头**,**有限状态自动机**。

所有可计算问题都可以用递归模型和 **图灵机** 模型求解

一个基于BSP模型的并行算法，假设有p台处理器，用于计算整数数组a[0..n-1]的所有元素之和，算法的时间复杂度为 **O(n/p+p)**

分支限界法与回溯法都是在问题的解空间树T上搜索问题的解，二者 **求解目标不同，搜索方式也不同**
  
**回溯法** 的求解目标是找出T中满足约束条件的 **所有解** ，而 **分支限界法** 的求解目标则是找出 **满足约束条件的一个解** ，或是在满足约束条件的解中找出使某一目标函数值达到 **极大或极小的解** ，即在某种意义下的 **最优解** 。

回溯算法和分支限界法的问题的解空间树是 **无需构造**

# 简述五大算法的基本思想及算法结构
五大算法基本思想包括分治，动态规划，贪心，回溯和分支限界法。

1. 分治法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。  
2. 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。  
3. 贪心算法（也叫贪婪算法）是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。  
4. 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。  
5. 分支限界法也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。

五大算法的算法结构如下：

1. 分治法的算法结构通常包括三个步骤：分解问题，解决子问题和合并子问题解。首先，将原问题分解为若干个规模较小的子问题；然后，递归地解决这些子问题；最后，将各个子问题的解合并为原问题的解。

2. 动态规划法的算法结构通常包括四个步骤：分析最优解的性质并刻画其结构特征，递归地定义最优值，以自底向上或自顶向下的方式计算出最优值，根据计算最优值时得到的信息构造一个最优解。

3. 贪心法的算法结构通常包括两个步骤：建立数学模型来描述问题，把求解的问题分成若干个子问题。对每一子问题求解，得到子问题的局部最优解。把子问题的局部最优解合成原来解问题的一个解。

4. 回溯法的算法结构通常包括两个步骤：针对所给问题，确定问题的解空间；确定结点的扩展搜索规则。以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

5. 分支限界法的算法结构通常包括两个步骤：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点；为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点。
# 先进先出队列/优先队列搜索的设计要点是什么？
先进先出队列（FIFO）和优先队列都是一种数据结构，它们的设计要点不同。

先进先出队列（FIFO）的设计要点是保证元素的出队顺序与它们的入队顺序相同。也就是说，最先入队的元素应该最先出队。

优先队列的设计要点是高效地将队列中优先级最高的那个元素弹出来（复杂度O (lgN)）。
# 请叙述动态规划算法与贪心算法的异同
动态规划和贪心算法都是用来求解最优化问题的算法。它们都试图通过一系列的决策来找到问题的最优解。但它们在解决问题的方法上有所不同。

动态规划是一种分阶段决策的方法。它将原问题分解为若干个子问题，通过求解子问题来推导出原问题的解。动态规划通常用于求解具有最优子结构性质的问题，即原问题的最优解可以由子问题的最优解推导出来。动态规划算法通常需要记录子问题的解，以避免重复计算。

贪心算法则是一种局部最优决策的方法。它在每一步都做出当前看来最优的选择，希望这样能够导致全局最优解。贪心算法通常用于求解具有贪心选择性质的问题，即局部最优选择能够导致全局最优解。

总之，动态规划和贪心算法都是用来求解最优化问题的算法，但它们在解决问题的方法上有所不同。动态规划通过分阶段决策来求解问题，而贪心算法则通过局部最优决策来求解问题。
# 衡量算法时间效率的方法有哪两种？请叙述。
衡量算法时间效率的方法主要有两种：**事后统计法**和**渐进时间复杂度**分析。

1.  事后统计法：这种方法是通过运行算法并测量其实际运行时间来衡量算法的时间效率。这种方法的优点是结果直观、准确，但缺点是受到硬件、软件和数据等多种因素的影响，不具有普遍性。
    
2.  渐进时间复杂度分析：这种方法是通过分析算法的执行步骤来估计算法的时间效率。它不关心具体的常数因子，而是关注算法运行时间随着问题规模增长的增长趋势。这种方法的优点是结果具有普遍性，不受硬件、软件和数据等因素的影响，但缺点是结果不够直观、准确。
    

总之，衡量算法时间效率的方法主要有事后统计法和渐进时间复杂度分析两种。它们各有优缺点，可以根据实际情况选择适当的方法来衡量算法的时间效率。
# 推荐阅读
- [数据结构与算法 | 我的笔记](https://github.com/Xancoding/Data-Structures-and-Algorithms)
***
- [LABULADONG 的算法网站](https://labuladong.github.io/algo/)
- [代码随想录 x 数据结构与算法](https://www.programmercarl.com/) 
- [AcWing 算法基础课](https://www.acwing.com/activity/content/11/)
- [AcWing 算法提高课](https://www.acwing.com/activity/content/16/)
- [AcWing 算法进阶课](https://www.acwing.com/activity/content/32/)
- [OI Wiki](https://oi-wiki.org/)
- [CP Wiki](https://cp-wiki.vercel.app/)
***
- [LeetCode](https://leetcode.cn/)
- [AcWing](https://www.acwing.com/)
- [Luogo](https://www.luogu.com.cn/)
- [Codeforces](https://codeforces.com/)
***
- [《大话数据结构》](https://book.douban.com/subject/6424904/)
- [《labuladong的算法小抄》](https://book.douban.com/subject/35252621/)
- [《算法竞赛进阶指南》](https://book.douban.com/subject/30136932/)
- [《算法（第4版）》](https://book.douban.com/subject/19952400/)
{{< douban src="https://book.douban.com/subject/6424904/" >}}
{{< douban src="https://book.douban.com/subject/35252621/" >}}
{{< douban src="https://book.douban.com/subject/30136932/" >}}
{{< douban src="https://book.douban.com/subject/19952400/" >}}