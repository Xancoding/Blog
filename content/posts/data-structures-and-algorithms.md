---
title: "数据结构与算法" # 标题
date: 2022-10-18T17:16:53+08:00 # 创建时间
author: ["Xan"] # 作者
tags: # 标签
- Tech
- 计算机基础
- 数据结构与算法
keywords: # 关键词
- Tech
- 计算机基础
- 数据结构与算法
description: "" # 描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true # 是否展示评论
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true # 顶部显示当前路径
cover:
    image: "" #图片路径 例：posts/tech/123/picture.png
    caption: "" # 图片底部描述
    alt: ""
    relative: false
---

# 分治法
分治法的关键步骤包括：
1. 分成子问题
2. 递归处理子问题
3. 子问题合并

分治法是一种求解问题的策略，而递归是一种实现求解算法的技术

改进分治算法的途径有 **减少子问题个数** 和 **增加预处理**。

在分治法处理中，实践证明，采用 **平衡子问题** 思想划分子问题总是有较好的结果。

在大整数乘法和矩阵乘中，可以采取降低  **乘法** 的运算次数来降低时间复杂度

分治法的设计思想是将一个难以直接解决的大问题分割成规模较小的子问题，分别解决子问题，最后将子问题的解组合起来形成原问题的解。这要求原问题和子问题 **问题规模不同，问题性质相同**
# 动态规划
虽然动态规划算法通常用于解决具有**重叠子问题**的问题，但是这并不是动态规划的必要条件。

动态规划算法的两个基本要素是 **子问题重叠** 性质和 **最优子结构** 性质 。

问题的 **子问题重叠** 是该问题可用动态规划算法或贪心算法求解的关键特征。

备忘录/填表方法是 **动态规划法** 算法的变形

动态规划算法基本要素的是 **子问题重叠**

能采用动态规划求解的问题必须要满足的性质是 **最优子结构**

动态规划算法的关键步骤包括：
1. 确定状态和状态转移方程
2. 确定初始状态和边界条件
3. 确定子问题求解顺序

**有重叠子问题并不是动态规划的必要条件**：
这是正确的。动态规划算法的核心思想是将一个大问题分解成许多小问题，并使用这些小问题的解来构建大问题的解。通常情况下，这些小问题是相互独立的，但是如果它们之间存在重叠，也就是说它们具有相同的子问题，那么动态规划算法可以利用这些重叠来避免重复计算，从而提高效率。  
然而，并不是所有的动态规划问题都具有重叠子问题。例如，有些动态规划问题只是简单地将一个问题分解成许多相互独立的子问题，而不是使用重叠子问题来避免重复计算。  
因此，具有重叠子问题并不是动态规划算法的必要条件，但是如果存在重叠子问题，动态规划算法可以更加高效地解决问题。  

**动态规划算法设计中标记函数不是必须的**
标记函数是指在动态规划算法中使用的一种技巧，用于记录某些子问题是否已经被求解过。当一个子问题被解决后，标记函数可以将其标记为已解决，从而在后续的计算中避免重复计算。标记函数通常用一个数组或哈希表来实现。  
尽管标记函数在许多动态规划问题中都非常有用，但并不是所有的动态规划问题都需要使用标记函数。实际上，有些动态规划问题的状态转移方程不需要考虑子问题是否已经被求解过，因为它们的状态转移方程本身已经保证了没有重复计算的问题。  
因此，动态规划算法设计中是否需要包含标记函数，取决于具体的问题和算法设计。在一些情况下，标记函数可以提高算法的效率，但在另一些情况下，它们可能不是必需的。

**状态转移方程和标记函数是两个不同的概念，在动态规划算法中起着不同的作用。**
状态转移方程是描述问题中子问题之间的转移关系，通常用来计算当前子问题的最优解。在动态规划算法中，我们将原问题分解成若干个子问题，并使用状态转移方程计算子问题的最优解，从而逐步构建出原问题的最优解。  
标记函数则是用来标记子问题的解是否已经被计算过。在动态规划算法中，由于子问题之间存在重叠，可能会重复计算同一个子问题的解，导致算法效率下降。标记函数可以用来避免这种情况的发生，当一个子问题的解已经被计算过后，我们可以将其标记为已计算，避免重复计算。  
在某些情况下，状态转移方程和标记函数可能是紧密相关的，例如在使用记忆化搜索优化动态规划算法时，我们通常会将已计算的子问题的解保存在一个表格中，作为标记函数来使用。但在其他情况下，状态转移方程和标记函数可能是相对独立的，可以根据具体问题和算法设计来灵活选择是否使用标记函数。
# 贪心法
**n皇后问题** 不能使用贪心法解决

贪心算法的基本要素的是 **定义最优解**
# 回溯法
![回溯法.jpg](https://bu.dusays.com/2023/05/12/645e4ab203f4e.jpg)
回溯法有“通用解题法”之称，它可以系统地搜索一个问题的所有解或任意解

回溯法是一种既带系统性又带有跳跃性的搜索算法

回溯算法在生成解空间的任一结点时，先判断该结点是否可能包含问题的解，如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向祖先结点回溯

回溯法的解空间树有 **子集树**、**排列树**、**n 叉树**

回溯法是一种 **带剪枝** 的穷举法，它采用了 **深度优先** 搜索方式，求得问题的 **最优解** 或所有解

回溯法中用到的两种约束条件是 **目标函数和约束函数** 两种

回溯法的效率不依赖于 **确定解空间的时间后问题**

**剪枝函数** 函数是回溯法中为避免无效搜索采取的策略
# 分支限界法
![分支限界法.jpg](https://bu.dusays.com/2023/05/12/645e4abaac35f.jpg)
优先队列式分枝限界法选取扩展结点的原则是 **结点的优先级**

采用最大效益优先搜索方式的算法是 **分支限界法**

分支限界法求解0/1背包问题时，活结点表的组织形式是 **大根堆**

常见的两种分支限界法为 **队列式（FIFO）分支限界法与优先队列式分支限界法**

分支限界法在问题的解空间树中，按 **广度优先** 策略，从根结点出发搜索解空间树
# 递推式的计算
## 主定理
假设 $T(n)$ 是一个递归算法的时间复杂度，其中 $n$ 是输入规模。假设算法分解问题时，将其划分为 $a$ 个子问题，每个子问题的规模为原问题的 $1/b$，且每个子问题的解需要 $f(n)$ 的时间。即：
$$T(n) = aT(n/b) + f(n)$$

假设分解问题和合并子问题的过程需要常数时间 $d$，那么主定理的公式如下：
### 易记（不严谨）
1.  如果 $f(n) < O(n^{\log_b(a)})$，那么 $T(n) = \Theta(n^{\log_b(a)})$
    
2.  如果 $f(n) = \Theta(n^{\log_b(a)})$，那么 $T(n) = \Theta(n^{\log_b(a)} \log n)$
    
3.  如果 $f(n) > \Omega(n^{\log_b(a)})$，那么 $T(n) = \Theta(f(n))$。
    

这里的比较指的是数量级的大小
### 严谨
1.  如果 $f(n) = O(n^{\log_b(a - \epsilon)})$，那么 $T(n) = \Theta(n^{\log_b(a)})$
    
2.  如果 $f(n) = \Theta(n^{\log_b(a)})$，那么 $T(n) = \Theta(n^{\log_b(a)} \log n)$
    
3.  如果 $f(n) = \Omega(n^{\log_b(a + \epsilon)})$，且对于某个常数 $c < 1$ 和所有足够大的 $n$ 都有 $af(n/b) \le cf(n)$，那么 $T(n) = \Theta(f(n))$。
    

其中 $\epsilon > 0$ 是任意小的正数。这里的 $O$、$\Theta$ 和 $\Omega$ 表示渐进符号。
# P & NP & NPC & NP-Hard 
NP问题是指可以在多项式的时间里验证一个解的问题

若一个问题可以找到一个能在多项式的时间里解决它的算法，该问题就属于P问题

NPC 问题不一定是个NP问题，只要保证所有的NP问题都可以约化到它即可。  

NPC问题指的是NP问题中最难的问题之一，同时也是NP问题中的一个子集，因此只要能将所有的NP问题约化为它，它就是NP问题。

所有的P类问题都是NP问题的子集。

-  P(Polynomial,多项式)问题，P问题是可以在多项式时间内被解决的问题。

-  NP类问题（Nondeterminism Polynomial）：在多项式时间内“可验证”的问题。也就是说，不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。即该问题的猜测过程是不确定的，而对其某一个解的验证则能够在多项式时间内完成。直白的说，就是可以在多项式的时间里猜出一个解的问题。

- NPC（Nondeterminism Polynomial complete）：存在这样一个NP问题，所有的NP问题都可以约化成它。
    
- NP-hard问题（NPH，NP-Hard）是指那些至少和NP问题一样难的问题。也就是说，如果存在一个多项式时间算法能够解决一个NP-hard问题，那么所有的NP问题都可以在多项式时间内解决。需要注意的是，NP-hard问题并不一定是NP问题，它们可能不具备在多项式时间内验证解的正确性的性质。

总之，NP完全问题和NP-hard问题都属于计算复杂度理论中难以解决的问题。它们之间的区别在于，NP完全问题既可以在多项式时间内验证解的正确性，又至少和其他NP问题一样难；而NP-hard问题只需满足后者的条件。
# 其他知识点
描述算法时间增长率上限用 **O** 符号，增长率下限用 **Ω** 符号表示。

图灵机模型的基本结构包括 纸带,**读写头**,**有限状态自动机**。

所有可计算问题都可以用递归模型和 **图灵机** 模型求解

一个基于BSP模型的并行算法，假设有p台处理器，用于计算整数数组a[0..n-1]的所有元素之和，算法的时间复杂度为 **O(n/p+p)**

# 推荐阅读
- [数据结构与算法 | 我的笔记](https://github.com/Xancoding/Data-Structures-and-Algorithms)
***
- [LABULADONG 的算法网站](https://labuladong.github.io/algo/)
- [代码随想录 x 数据结构与算法](https://www.programmercarl.com/) 
- [AcWing 算法基础课](https://www.acwing.com/activity/content/11/)
- [AcWing 算法提高课](https://www.acwing.com/activity/content/16/)
- [AcWing 算法进阶课](https://www.acwing.com/activity/content/32/)
- [OI Wiki](https://oi-wiki.org/)
- [CP Wiki](https://cp-wiki.vercel.app/)
***
- [LeetCode](https://leetcode.cn/)
- [AcWing](https://www.acwing.com/)
- [Luogo](https://www.luogu.com.cn/)
- [Codeforces](https://codeforces.com/)
***
- [《大话数据结构》](https://book.douban.com/subject/6424904/)
- [《labuladong的算法小抄》](https://book.douban.com/subject/35252621/)
- [《算法竞赛进阶指南》](https://book.douban.com/subject/30136932/)
- [《算法（第4版）》](https://book.douban.com/subject/19952400/)
{{< douban src="https://book.douban.com/subject/6424904/" >}}
{{< douban src="https://book.douban.com/subject/35252621/" >}}
{{< douban src="https://book.douban.com/subject/30136932/" >}}
{{< douban src="https://book.douban.com/subject/19952400/" >}}