---
title: "C++ Sort Function & Priority Queue" # 标题
date: 2023-04-24T14:17:47+08:00 # 创建时间
author: ["Xan"] # 作者
tags: # 标签
- C++ 
- Tech 
keywords: # 关键词
- C++ 
- Tech 
description: "" # 描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true # 是否展示评论
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true # 顶部显示当前路径
cover:
    image: "" #图片路径 例：posts/tech/123/picture.png
    caption: "" # 图片底部描述
    alt: ""
    relative: false
---

当使用 `sort函数` 和 `Priority_queue优先队列` 时， `Container` 中的元素会被自动排序

当待排列的元素为一个对象时，我们既可以通过自定义比较函数，也可以通过重载运算符来达到目的。

# Sort函数
## 重载运算符
sort函数在默认情况下使用`std::less`作为比较函数类，即升序排序，而`std::less`需要重载小于号`<`运算符。

如果要实现降序排序，可以使用`std::greater`作为比较函数类，那么就需要重载大于号`>`运算符。  

当第一个元素 < 第二个元素时，为`true`，则最终的排序结果为升序

同理，当我把 `this->age < other.age` 修改为 `this->age > other.age`时，说明当第一个元素 > 第二个元素时，为`true`，则结果为降序

通过下述代码，我们可以在调用`sort`时将比较函数类从默认的`std::less`改为`std::greater`，实现降序排序--前提是记得在对象中重载大于运算符，否则编译器将会报错！！！
```cpp
sort(people.begin(), people.end(), greater<>());
```

## 自定义比较函数


# Priority_queue堆优先队列 
堆是一种数据结构，可以用数组或树实现，常用于实现优先队列、排序算法等。  

优先队列（priority queue）就是堆（heap）的一种应用。

C++中的优先队列实现就是堆优先队列，底层使用堆来实现。  

`std::priority_queue`是一个模板类，它的模板参数有三个，分别是：

1.  `T`：指定队列中存储的元素类型。
2.  `Container`：指定用于存储元素的容器类型，默认是`std::vector<T>`。
3.  `Compare`：指定用于比较元素优先级的比较函数类型，默认是`std::less<T>`。

`std::less<T>`和`std::greater<T>`是STL中预定义的两个比较函数类，分别表示小于和大于。它们重载了小于号运算符`<`和大于号运算符`>`，用于比较元素的优先级。因此，当我们在定义`std::priority_queue`时，使用`std::less<T>`作为比较函数类时，实际上是默认按照小于号进行比较元素优先级；而使用`std::greater<T>`作为比较函数类时，则是按照大于号进行比较元素优先级。

如果在使用`std::less<T>`作为比较函数类时，重载大于号`>`，或者在使用`std::greater<T>`作为比较函数类时，重载小于号`<`，都会导致编译错误，因为这些比较函数类内部的比较操作都是用小于号`<`或者大于号`>`实现的，而你重载了不符合预期的运算符，导致编译器无法正确地进行比较操作。

在C++中，优先队列可以通过指定比较函数来控制是使用大根堆还是小根堆。如果使用 std::greater<> 作为比较函数，则意味着使用小根堆，即优先级高的元素会被放在队列的顶部；如果使用 std::less<> 作为比较函数，则意味着使用大根堆，即优先级高的元素会被放在队列的底部。  

堆中元素之间的优先级关系，这是通过定义比较函数来实现的，比较函数中使用 `greater<>` 表示元素之间的优先级关系为第一个参数视为较小的元素；使用 `less<>` 表示元素之间的优先级关系为第一个参数视为较大的元素。  

使用 `greater<>` 作为比较函数时，会将元素之间的优先级关系视为第一个参数较小，也就是说，若 `greater<>` 作为比较函数返回 true，则表示第二个参数优先级高于第一个参数，应当排在第一个参数之前。因此，这里的“将第一个参数视为较小的元素”指的是将第一个参数作为比较时的较小值，从而实现小根堆的效果。  

在一个二元比较函数中，第一个参数一般是被比较的左侧参数，第二个参数是被比较的右侧参数。比如在 `operator>` 函数中，第一个参数就是使用 `>` 运算符的左侧参数，第二个参数是右侧参数。在优先队列中，第一个参数也就是堆顶元素。
```cpp
#include <iostream>  
#include <queue>  
#include <functional>  
using namespace std;  
  
class Person {  
public:  
string name;  
int age;  
  
Person(string name, int age) : name(name), age(age) {}  
  
bool operator>(const Person& other) const {  
return age > other.age;  
}  
};  
  
int main() {  
priority_queue<Person, vector<Person>, greater<>> pq;  
  
// 插入元素  
pq.push(Person("张三", 20));  
pq.push(Person("李四", 30));  
pq.push(Person("王五", 25));  
  
cout << "这是一个小根堆！！！\n";  
while (!pq.empty())  
{  
auto& p = pq.top();  
cout << "Name:" << p.name << '\t' << "Age:" << p.age << '\n';  
pq.pop();  
}  
  
return 0;  
}
```
输出结果： 
```cpp
这是一个小根堆！！！
Name:张三       Age:20
Name:王五       Age:25
Name:李四       Age:30
```

